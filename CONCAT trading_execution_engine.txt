# Module: components/trading_execution_engine

# File: components/trading_execution_engine/__init__.py
# Type: py

# File: components/trading_execution_engine/__init__.py
# Type: py

from .execution_engine import ExecutionEngine
from .trade_signal import TradeSignal
from .alpaca_api import AlpacaAPIClient
from .order_manager import OrderManager
from .config import CONFIG

__all__ = [
    'ExecutionEngine',
    'TradeSignal',
    'AlpacaAPIClient',
    'OrderManager',
    'CONFIG'
]


# File: components/trading_execution_engine/alpaca_api.py
# Type: py

# File: components/trading_execution_engine/alpaca_api.py
# Type: py

import aiohttp
import asyncio
import logging
from .config import CONFIG

class AlpacaAPIClient:
    """Client for interacting with Alpaca's REST API asynchronously"""

    def __init__(self):
        self.logger = self._setup_logging()
        self.base_url = CONFIG['alpaca']['base_url']
        self.api_key = CONFIG['alpaca']['key_id']
        self.api_secret = CONFIG['alpaca']['secret_key']
        self.headers = {
            'APCA-API-KEY-ID': self.api_key,
            'APCA-API-SECRET-KEY': self.api_secret
        }
        self.session = aiohttp.ClientSession(headers=self.headers)

    def _setup_logging(self):
        logger = logging.getLogger('alpaca_api')
        logger.setLevel(logging.INFO)
        handler = logging.FileHandler(CONFIG['logging']['log_file'])
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        logger.addHandler(handler)
        return logger

    async def close(self):
        """Closes the aiohttp session and waits for all tasks to be completed."""
        if not self.session.closed:
            await self.session.close()
            self.logger.info("aiohttp session closed.")


    async def place_order_async(self, order_params):
        """
        Places an order asynchronously.
        """
        url = f"{self.base_url}/v2/orders"
        for attempt in range(3):  # Retry up to 3 times
            try:
                async with self.session.post(url, json=order_params, timeout=10) as response:
                    if response.status == 200 or response.status == 201:
                        order = await response.json()
                        self.logger.info(f"Order placed: {order}")
                        return order
                    else:
                        error_text = await response.text()
                        self.logger.error(f"Error placing order: {response.status} {error_text}")
                        response.raise_for_status()
            except aiohttp.ClientError as e:
                self.logger.warning(f"Attempt {attempt + 1} failed: {e}")
                await asyncio.sleep(2 ** attempt)  # Exponential backoff
                if attempt == 2:
                    self.logger.error(f"Failed to place order after 3 attempts")
                    raise
            except Exception as e:
                self.logger.error(f"Unexpected error: {e}")
                raise

    async def get_order_status_async(self, order_id):
        """
        Retrieves the status of an order asynchronously.
        """
        url = f"{self.base_url}/v2/orders/{order_id}"
        try:
            async with self.session.get(url, timeout=10) as response:
                response.raise_for_status()
                order = await response.json()
                return order
        except aiohttp.ClientError as e:
            self.logger.error(f"Error retrieving order status: {e}")
            raise

    async def get_account_info_async(self):
        """
        Retrieves account information asynchronously.
        """
        url = f"{self.base_url}/v2/account"
        try:
            async with self.session.get(url, timeout=10) as response:
                response.raise_for_status()
                account_info = await response.json()
                return account_info
        except aiohttp.ClientError as e:
            self.logger.error(f"Error retrieving account info: {e}")
            raise

    async def get_positions_async(self):
        """
        Retrieves all open positions asynchronously.
        """
        url = f"{self.base_url}/v2/positions"
        try:
            async with self.session.get(url, timeout=10) as response:
                response.raise_for_status()
                positions = await response.json()
                return positions
        except aiohttp.ClientError as e:
            self.logger.error(f"Error retrieving positions: {e}")
            raise

    async def get_position_async(self, ticker):
        """
        Retrieves a specific position asynchronously.
        """
        url = f"{self.base_url}/v2/positions/{ticker}"
        try:
            async with self.session.get(url, timeout=10) as response:
                response.raise_for_status()
                position = await response.json()
                return position
        except aiohttp.ClientError as e:
            self.logger.error(f"Error retrieving position for {ticker}: {e}")
            raise

    async def cancel_all_orders_async(self):
        """
        Cancels all open orders asynchronously.
        """
        url = f"{self.base_url}/v2/orders"
        for attempt in range(3):  # Retry up to 3 times
            try:
                async with self.session.delete(url, timeout=10) as response:
                    if response.status in (200, 204):
                        self.logger.info("All open orders have been canceled.")
                        return await response.json() if response.content_length else None
                    else:
                        error_text = await response.text()
                        self.logger.error(f"Error canceling orders: {response.status} {error_text}")
                        response.raise_for_status()
            except aiohttp.ClientError as e:
                self.logger.warning(f"Attempt {attempt + 1} to cancel all orders failed: {e}")
                await asyncio.sleep(2 ** attempt)  # Exponential backoff
                if attempt == 2:
                    self.logger.error("Failed to cancel all orders after 3 attempts")
                    raise
            except Exception as e:
                self.logger.error(f"Unexpected error canceling orders: {e}")
                raise

    async def cancel_order_async(self, order_id: str):
        """
        Cancels a specific order asynchronously.
        """
        url = f"{self.base_url}/v2/orders/{order_id}"
        for attempt in range(3):  # Retry up to 3 times
            try:
                async with self.session.delete(url, timeout=10) as response:
                    if response.status in (200, 204):
                        self.logger.info(f"Order {order_id} has been canceled.")
                        return await response.json() if response.content_length else None
                    else:
                        error_text = await response.text()
                        self.logger.error(f"Error canceling order {order_id}: {response.status} {error_text}")
                        response.raise_for_status()
            except aiohttp.ClientError as e:
                self.logger.warning(f"Attempt {attempt + 1} to cancel order {order_id} failed: {e}")
                await asyncio.sleep(2 ** attempt)  # Exponential backoff
                if attempt == 2:
                    self.logger.error(f"Failed to cancel order {order_id} after 3 attempts")
                    raise
            except Exception as e:
                self.logger.error(f"Unexpected error canceling order {order_id}: {e}")
                raise


# File: components/trading_execution_engine/config.py
# Type: py

# File: components/trading_execution_engine/config.py
# Type: py

import os
from configparser import ConfigParser

# Create directories if they don't exist
os.makedirs('logs', exist_ok=True)
os.makedirs('data', exist_ok=True)

# Initialize ConfigParser
config_parser = ConfigParser()

# Load configuration from file if it exists
config_file_path = os.path.join('config', 'config.ini')
if os.path.exists(config_file_path):
    config_parser.read(config_file_path)
else:
    print(f"Configuration file not found at {config_file_path}. Using environment variables.")

# Alpaca API Settings
APCA_API_BASE_URL = os.getenv('APCA_API_BASE_URL') or config_parser.get('alpaca', 'base_url', fallback='https://paper-api.alpaca.markets/v2')
APCA_API_KEY_ID = os.getenv('APCA_API_KEY_ID') or config_parser.get('alpaca', 'key_id', fallback=None)
APCA_API_SECRET_KEY = os.getenv('APCA_API_SECRET_KEY') or config_parser.get('alpaca', 'secret_key', fallback=None)

if not APCA_API_KEY_ID or not APCA_API_SECRET_KEY:
    raise EnvironmentError("Alpaca API credentials not found. Please set environment variables or update the config file.")

# Risk Management Settings
MAX_POSITION_SIZE_PCT = float(os.getenv('MAX_POSITION_SIZE_PCT') or config_parser.get('risk', 'max_position_size_pct', fallback=0.1))
MAX_ORDER_VALUE = float(os.getenv('MAX_ORDER_VALUE') or config_parser.get('risk', 'max_order_value', fallback=50000.0))
DAILY_LOSS_LIMIT_PCT = float(os.getenv('DAILY_LOSS_LIMIT_PCT') or config_parser.get('risk', 'daily_loss_limit_pct', fallback=0.02))

# Logging Settings
LOG_FILE = os.path.join('logs', 'execution_engine.log')

# Configuration Dictionary
CONFIG = {
    'alpaca': {
        'base_url': APCA_API_BASE_URL,
        'key_id': APCA_API_KEY_ID,
        'secret_key': APCA_API_SECRET_KEY
    },
    'logging': {
        'log_file': LOG_FILE
    },
    'database': {
        'orders_db': os.path.join('data', 'orders.db')
    },
    'risk': {
        'max_position_size_pct': MAX_POSITION_SIZE_PCT,
        'max_order_value': MAX_ORDER_VALUE,
        'daily_loss_limit_pct': DAILY_LOSS_LIMIT_PCT
    }
}

# Make config available for import
__all__ = ['CONFIG']


# File: components/trading_execution_engine/execution_engine.py
# Type: py

# File: components/trading_execution_engine/execution_engine.py
# Type: py

import os
import asyncio
import threading
import queue
import json
from datetime import datetime, time
import pytz
import logging
from typing import Optional, Dict, Any
from .trade_signal import TradeSignal
from .order_manager import OrderManager
from .alpaca_api import AlpacaAPIClient
from .config import CONFIG

# File: components/trading_execution_engine/execution_engine.py
# Type: py

# File: components/trading_execution_engine/execution_engine.py
# Type: py

class ExecutionEngine:
    """
    Processes trade signals asynchronously and executes trades with error recovery.
    """

    def __init__(
        self,
        alpaca_client: Optional[AlpacaAPIClient] = None,
        order_manager: Optional[OrderManager] = None
    ):
        self.signal_queue = queue.Queue()
        self.order_manager = order_manager if order_manager else OrderManager()
        self.alpaca_client = alpaca_client if alpaca_client else AlpacaAPIClient()
        self.logger = self._setup_logging()
        self.loop = asyncio.get_event_loop()
        self.daily_pnl = 0.0
        self.risk_config = CONFIG['risk']
        self.recovery_interval = 300  # 5 minutes
        self.max_retries = 3
        self.retry_delays = [2, 5, 10]  # Exponential backoff delays in seconds
        self._active_orders: Dict[str, Dict[str, Any]] = {}

        self._start_recovery_task()




    def _setup_logging(self):
        logger = logging.getLogger('execution_engine')
        logger.setLevel(logging.INFO)
        handler = logging.FileHandler(CONFIG['logging']['log_file'])
        handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
        logger.addHandler(handler)
        return logger

    def _run_event_loop(self):
        """Runs the event loop for processing signals."""
        asyncio.set_event_loop(self.loop)
        self.loop.run_until_complete(self._process_signals())

    def _start_recovery_task(self):
        """Starts the periodic recovery task for failed trades."""
        async def run_recovery():
            while not self.stop_event.is_set():
                # If in test mode, reduce the sleep interval to quickly exit
                interval = 0.1 if os.getenv("TEST_MODE") else self.recovery_interval
                await asyncio.sleep(interval)
                if self.stop_event.is_set():
                    break
                try:
                    await self._recover_failed_trades()
                except Exception as e:
                    self.logger.error(f"Error in recovery task: {e}")

        asyncio.run_coroutine_threadsafe(run_recovery(), self.loop)

    # File: components/trading_execution_engine/execution_engine.py
    # Type: py

    async def _recover_failed_trades(self):
        """Attempts to recover failed trades with retry logic."""
        try:
            failed_trades = self._get_pending_failed_trades_for_recovery()
            for trade_info in failed_trades:
                trade_id, trade_signal_json, error_message, retry_count = trade_info
                await self._recover_single_failed_trade(trade_id, trade_signal_json, error_message, retry_count)
        except Exception as e:
            self.logger.error(f"Error in recovery process: {e}")

    def _get_pending_failed_trades_for_recovery(self):
        """Retrieves pending failed trades from the order manager for recovery."""
        return self.order_manager.get_pending_failed_trades(self.max_retries)

    async def _recover_single_failed_trade(self, trade_id, trade_signal_json, error_message, retry_count):
        """Attempts to recover a single failed trade."""
        self.logger.info(f"Attempting to recover failed trade {trade_id}, retry {retry_count + 1}")
        try:
            trade_signal_dict = json.loads(trade_signal_json)
            trade_signal = TradeSignal.from_dict(trade_signal_dict)

            delay = self.retry_delays[min(retry_count, len(self.retry_delays) - 1)]
            await asyncio.sleep(delay)

            if await self.validate_trade_signal(trade_signal):
                await self.execute_trade_with_recovery(trade_signal, is_recovery=True)
                self.order_manager.update_failed_trade_status(trade_id, 'resolved')
                self.logger.info(f"Successfully recovered trade {trade_id}")
            else:
                await self.handle_failed_trade(
                    trade_signal,
                    "Trade signal validation failed during recovery",
                    trade_id
                )
        except Exception as e:
            self.logger.error(f"Error recovering trade {trade_id}: {e}")
            if retry_count + 1 >= self.max_retries:
                self.order_manager.update_failed_trade_status(trade_id, 'failed')
            else:
                # Attempt to get trade_signal from locals if it was successfully created, else pass None.
                await self.handle_failed_trade(
                    locals().get('trade_signal'),
                    str(e),
                    trade_id
                )
        finally:
            # Wait a brief moment before processing the next trade to avoid flooding logs.
            await asyncio.sleep(1)


    async def _process_signals(self):
        """Processes trade signals from the queue."""
        while not self.stop_event.is_set():
            try:
                trade_signal = await self.loop.run_in_executor(None, self.signal_queue.get)
                if trade_signal is None:
                    continue
                await self.execute_trade_signal(trade_signal)
            except Exception as e:
                self.logger.error(f"Error processing trade signal: {e}")
                if isinstance(trade_signal, TradeSignal):
                    await self.handle_failed_trade(trade_signal, str(e))

    async def handle_failed_trade(self, trade_signal: TradeSignal, error_message: str,
                                  existing_trade_id: Optional[str] = None):
        """Handles failed trades by logging and initiating recovery process."""
        try:
            if existing_trade_id:
                self.order_manager.update_failed_trade_status(
                    existing_trade_id, 'retry', error_message
                )
            else:
                self.order_manager.log_failed_trade(trade_signal, error_message)

            self.logger.error(f"Trade failed: {error_message}")

            order_id = self._active_orders.get(trade_signal.strategy_id)
            if order_id:
                try:
                    await self.alpaca_client.cancel_order_async(order_id)
                except Exception as e:
                    self.logger.error(f"Error canceling failed order {order_id}: {e}")
                finally:
                    self._active_orders.pop(trade_signal.strategy_id, None)

        except Exception as e:
            self.logger.error(f"Error handling failed trade: {e}")

    async def validate_trade_signal(self, trade_signal: TradeSignal) -> bool:
        """Validates trade signal against risk management rules."""
        try:
            account_info = await self.alpaca_client.get_account_info_async()
            portfolio_value = float(account_info['portfolio_value'])

            if trade_signal.price is None and trade_signal.order_type == 'market':
                trade_signal.price = 0.0  # Default to 0 if price not provided

            validation_price = (trade_signal.limit_price if trade_signal.order_type == 'limit'
                                else trade_signal.stop_price if trade_signal.order_type == 'stop'
                                else trade_signal.price)

            order_value = trade_signal.quantity * validation_price
            max_position_value = portfolio_value * self.risk_config['max_position_size_pct']

            if order_value > max_position_value:
                self.logger.warning(f"Order value {order_value} exceeds maximum position size {max_position_value}")
                return False

            if order_value > self.risk_config['max_order_value']:
                self.logger.warning(f"Order value {order_value} exceeds maximum order value {self.risk_config['max_order_value']}")
                return False

            if self.daily_pnl <= -(portfolio_value * self.risk_config['daily_loss_limit_pct']):
                self.logger.warning("Daily loss limit reached")
                return False

            return True

        except Exception as e:
            self.logger.error(f"Error validating trade signal: {e}")
            return False

    def add_trade_signal(self, trade_signal: TradeSignal):
        """Adds a trade signal to the processing queue."""
        self.signal_queue.put(trade_signal)
        self.logger.info(f"Trade signal added to queue: {trade_signal}")

    def is_market_open(self) -> bool:
        """Checks if the market is currently open."""
        tz = pytz.timezone('America/New_York')
        now = datetime.now(tz)
        market_open = time(9, 30)
        market_close = time(16, 0)
        return market_open <= now.time() <= market_close

    async def execute_trade_signal(self, trade_signal: TradeSignal):
        """Main method for executing trade signals with error handling."""
        if not self.is_market_open():
            self.logger.warning("Market is closed. Trade signal will not be executed.")
            await self.handle_failed_trade(trade_signal, "Market closed")
            return

        self.logger.info(f"Processing trade signal: {trade_signal}")
        try:
            if not await self.validate_trade_signal(trade_signal):
                await self.handle_failed_trade(trade_signal, "Trade signal validation failed")
                return
            await self.execute_trade_with_recovery(trade_signal)
        except Exception as e:
            self.logger.error(f"Error executing trade signal: {e}")
            await self.handle_failed_trade(trade_signal, str(e))

    async def execute_trade_with_recovery(self, trade_signal: TradeSignal, is_recovery: bool = False):
        """Executes a trade with built-in recovery mechanisms."""
        for attempt in range(self.max_retries):
            try:
                await self.place_order(trade_signal)
                return True
            except Exception as e:
                if attempt == self.max_retries - 1:
                    if not is_recovery:
                        await self.handle_failed_trade(trade_signal, str(e))
                    raise
                delay = self.retry_delays[attempt]
                self.logger.warning(f"Retrying trade after {delay}s. Error: {e}")
                await asyncio.sleep(delay)
        return False

    # File: components/trading_execution_engine/execution_engine.py

    async def place_order(self, trade_signal: TradeSignal):
        """Places an order with the broker."""
        self.logger.info(f"Placing order for trade signal: {trade_signal}")
        start_time = datetime.now()

        order_params = {
            'symbol': trade_signal.ticker,
            'qty': trade_signal.quantity,
            'side': trade_signal.signal_type.lower(),  # e.g. 'buy' or 'sell'
            'type': trade_signal.order_type,
            'time_in_force': trade_signal.time_in_force,
            'client_order_id': trade_signal.strategy_id
        }

        if trade_signal.order_type == 'limit':
            order_params['limit_price'] = trade_signal.limit_price
        elif trade_signal.order_type == 'stop':
            order_params['stop_price'] = trade_signal.stop_price

        try:
            order = await self.alpaca_client.place_order_async(order_params)
            execution_time = (datetime.now() - start_time).total_seconds()
            self.logger.info(f"Order placed successfully: {order} (execution time: {execution_time:.3f}s)")

            order['is_manual'] = 1 if trade_signal.strategy_id == 'manual_trade' else 0
            order['execution_time'] = execution_time
            order['side'] = order_params['side']  # Ensure 'side' is recorded

            self.order_manager.add_order(order)
            self._active_orders[trade_signal.strategy_id] = order['id']
            await self.check_order_status(order['id'])
        except Exception as e:
            self.logger.error(f"Error placing order: {e}")
            raise


    async def check_order_status(self, order_id: str):
        """Monitors the status of a placed order."""
        self.logger.info(f"Checking status for order ID: {order_id}")
        try:
            for _ in range(10):  # Check status up to 10 times
                order = await self.alpaca_client.get_order_status_async(order_id)
                status = order['status']
                self.logger.info(f"Order {order_id} status: {status}")
                self.order_manager.update_order(order)

                if status == 'filled':
                    self.logger.info(f"Order {order_id} filled.")
                    await self.update_daily_pnl()
                    break
                elif status in ('canceled', 'rejected'):
                    self.logger.warning(f"Order {order_id} {status}.")
                    break

                await asyncio.sleep(5)
            else:
                self.logger.error(f"Order {order_id} status check timed out.")
        except Exception as e:
            self.logger.error(f"Error checking order status: {e}")
            raise

    async def update_daily_pnl(self):
        """Updates the daily P&L based on account information."""
        try:
            account_info = await self.alpaca_client.get_account_info_async()
            self.daily_pnl = float(account_info.get('equity')) - float(account_info.get('last_equity'))
            self.logger.info(f"Updated daily P&L: {self.daily_pnl}")
        except Exception as e:
            self.logger.error(f"Error updating daily P&L: {e}")

    async def update_portfolio(self):
        """Updates portfolio information."""
        self.logger.info("Updating portfolio information.")
        try:
            account_info = await self.alpaca_client.get_account_info_async()
            positions = await self.alpaca_client.get_positions_async()
            self.logger.info(f"Account balance: {account_info['cash']}")
            self.logger.info(f"Current positions: {positions}")
        except Exception as e:
            self.logger.error(f"Error updating portfolio: {e}")
            raise

    async def liquidate_position(self, ticker: str):
        """Liquidates a specific position."""
        self.logger.info(f"Liquidating position for {ticker}")
        try:
            position = await self.alpaca_client.get_position_async(ticker)
            qty = position['qty']
            trade_signal = TradeSignal(
                ticker=ticker,
                signal_type='SELL',
                quantity=float(qty),
                strategy_id='liquidation',
                timestamp=datetime.utcnow(),
                price=None
            )
            await self.execute_trade_with_recovery(trade_signal)
        except Exception as e:
            self.logger.error(f"Error liquidating position: {e}")
            raise

    async def liquidate_all_positions(self):
        """Liquidates all positions."""
        self.logger.info("Liquidating all positions.")
        try:
            positions = await self.alpaca_client.get_positions_async()
            tasks = []
            for position in positions:
                ticker = position['symbol']
                qty = position['qty']
                trade_signal = TradeSignal(
                    ticker=ticker,
                    signal_type='SELL',
                    quantity=float(qty),
                    strategy_id='liquidation',
                    timestamp=datetime.utcnow(),
                    price=None
                )
                tasks.append(self.execute_trade_with_recovery(trade_signal))
            await asyncio.gather(*tasks)
            self.logger.info("All positions have been liquidated.")
        except Exception as e:
            self.logger.error(f"Error liquidating all positions: {e}")
            for position in positions:
                try:
                    ticker = position['symbol']
                    await self.handle_failed_trade(
                        TradeSignal(
                            ticker=ticker,
                            signal_type='SELL',
                            quantity=float(position['qty']),
                            strategy_id='liquidation_recovery',
                            timestamp=datetime.utcnow(),
                            price=None
                        ),
                        f"Failed during bulk liquidation: {str(e)}"
                    )
                except Exception as inner_e:
                    self.logger.error(f"Error handling failed liquidation for {ticker}: {inner_e}")
            raise

    async def cancel_all_orders(self):
        """Cancels all pending orders."""
        self.logger.info("Canceling all pending orders.")
        try:
            self._active_orders.clear()
            await self.alpaca_client.cancel_all_orders_async()
            self.logger.info("All orders have been canceled.")
        except Exception as e:
            self.logger.error(f"Error canceling all orders: {e}")
            raise

    async def shutdown(self):
        """Gracefully shuts down the engine, ensuring resources are cleaned up."""
        self.logger.info("Shutting down execution engine.")
        # Cancel the recovery task if it exists
        if hasattr(self, '_recovery_task') and self._recovery_task is not None:
            self._recovery_task.cancel()
            del self._recovery_task

        # Run cleanup
        await self.cleanup()

        # Close the Alpaca API client session
        await self.alpaca_client.close()

        self.logger.info("Execution engine shutdown complete.")

    async def shutdown(self):
        """Gracefully shuts down the engine, ensuring resources are cleaned up."""
        self.logger.info("Shutting down execution engine.")
        # Cancel the recovery task if it exists
        if hasattr(self, '_recovery_task') and self._recovery_task is not None:
            self._recovery_task.cancel()

        # Run cleanup
        await self.cleanup()

        # Close the Alpaca API client session
        await self.alpaca_client.close()

        self.logger.info("Execution engine shutdown complete.")

    async def cleanup(self):
        """Performs cleanup operations before shutdown."""
        try:
            self.logger.info("Starting cleanup process.")
            await self.cancel_all_orders()

            while not self.signal_queue.empty():
                try:
                    trade_signal = self.signal_queue.get_nowait()
                    if trade_signal is not None:
                        await self.handle_failed_trade(
                            trade_signal,
                            "Trade signal not processed due to shutdown"
                        )
                except queue.Empty:
                    break

            # Final status update for active orders
            final_status_updates = []
            for strategy_id, order_id in self._active_orders.items():
                try:
                    order = await self.alpaca_client.get_order_status_async(order_id)
                    self.order_manager.update_order(order)
                    final_status_updates.append(f"Order {order_id}: {order['status']}")
                except Exception as e:
                    self.logger.error(f"Error updating final status for order {order_id}: {e}")

            if final_status_updates:
                self.logger.info("Final order statuses: %s", ", ".join(final_status_updates))

        except Exception as e:
            self.logger.error(f"Error during cleanup: {e}")
        finally:
            self._active_orders.clear()




if __name__ == '__main__':
    execution_engine = ExecutionEngine()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        execution_engine.shutdown()


# File: components/trading_execution_engine/order_manager.py
# Type: py

# File: components/trading_execution_engine/order_manager.py
# Type: py

import sqlite3
import os
import json
from datetime import datetime
from typing import Optional, Dict, Any
from .config import CONFIG  # Changed from config

class OrderManager:
    """
    Tracks order statuses and manages executions with performance monitoring.
    """

    def __init__(self):
        self.db_file = CONFIG['database']['orders_db']  # Changed from config
        os.makedirs('data', exist_ok=True)
        self.conn = sqlite3.connect(self.db_file, check_same_thread=False)
        self.conn.execute('PRAGMA journal_mode=WAL;')
        try:
            self._create_tables()
        except Exception as e:
            print(f"Error initializing database: {e}")
            raise

    def _create_tables(self):
        try:
            with self.conn:
                # Orders table
                self.conn.execute('''
                    CREATE TABLE IF NOT EXISTS orders (
                        order_id TEXT PRIMARY KEY,
                        ticker TEXT,
                        quantity REAL,
                        side TEXT,
                        status TEXT,
                        submitted_at TEXT,
                        filled_at TEXT,
                        filled_qty REAL,
                        strategy_id TEXT,
                        execution_price REAL,
                        is_manual INTEGER DEFAULT 0
                    )
                ''')

                # Failed trades table
                self.conn.execute('''
                    CREATE TABLE IF NOT EXISTS failed_trades (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        trade_signal TEXT,
                        error_message TEXT,
                        timestamp TEXT,
                        retry_count INTEGER DEFAULT 0,
                        status TEXT DEFAULT 'pending',
                        last_retry TEXT,
                        resolved_at TEXT
                    )
                ''')

                # Error log table
                self.conn.execute('''
                    CREATE TABLE IF NOT EXISTS error_log (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        order_id TEXT,
                        error_type TEXT,
                        error_message TEXT,
                        timestamp TEXT,
                        additional_info TEXT
                    )
                ''')

                # Execution metrics table
                self.conn.execute('''
                    CREATE TABLE IF NOT EXISTS execution_metrics (
                        order_id TEXT PRIMARY KEY,
                        submission_time TEXT,
                        execution_time TEXT,
                        execution_latency REAL,
                        intended_price REAL,
                        execution_price REAL,
                        price_slippage REAL,
                        order_type TEXT,
                        market_impact REAL,
                        strategy_id TEXT,
                        success INTEGER DEFAULT 1,
                        FOREIGN KEY (order_id) REFERENCES orders(order_id)
                    )
                ''')
        except sqlite3.Error as e:
            print(f"Error creating tables: {e}")
            raise

    def add_order(self, order_info: Dict[str, Any]) -> None:
        """Adds a new order to the database with initial metrics."""
        if not isinstance(order_info, dict):
            raise ValueError("order_info must be a dictionary")

        try:
            with self.conn:
                # Insert order
                self.conn.execute('''
                    INSERT OR REPLACE INTO orders (
                        order_id, ticker, quantity, side, status, submitted_at,
                        filled_at, filled_qty, strategy_id, execution_price, is_manual
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    order_info['id'],
                    order_info['symbol'],
                    float(order_info['qty']),
                    order_info['side'],
                    order_info['status'],
                    order_info.get('submitted_at'),
                    order_info.get('filled_at'),
                    float(order_info.get('filled_qty', 0)),
                    order_info.get('client_order_id', ''),
                    float(order_info.get('filled_avg_price', 0)),
                    order_info.get('is_manual', 0)
                ))

                # Initialize execution metrics
                self.conn.execute('''
                    INSERT OR REPLACE INTO execution_metrics (
                        order_id, submission_time, order_type, strategy_id
                    ) VALUES (?, ?, ?, ?)
                ''', (
                    order_info['id'],
                    order_info.get('submitted_at'),
                    order_info.get('type', 'market'),
                    order_info.get('client_order_id', '')
                ))
        except sqlite3.Error as e:
            self.log_error(order_info.get('id'), 'database_error', str(e))
            raise
        except Exception as e:
            self.log_error(order_info.get('id'), 'unexpected_error', str(e))
            raise

    def update_order(self, order_info: Dict[str, Any]):
        """
        Updates an existing order and its execution metrics.
        """
        try:
            with self.conn:
                # Update order status
                self.conn.execute('''
                    UPDATE orders SET
                        status = ?,
                        filled_at = ?,
                        filled_qty = ?,
                        execution_price = ?
                    WHERE order_id = ?
                ''', (
                    order_info['status'],
                    order_info.get('filled_at'),
                    float(order_info.get('filled_qty', 0)),
                    float(order_info.get('filled_avg_price', 0)),
                    order_info['id']
                ))

                # Update execution metrics
                if order_info['status'] == 'filled':
                    submission_time = datetime.fromisoformat(order_info['submitted_at'].replace('Z', '+00:00')) if order_info.get('submitted_at') else datetime.utcnow()
                    fill_time = datetime.fromisoformat(order_info['filled_at'].replace('Z', '+00:00')) if order_info.get('filled_at') else datetime.utcnow()
                    execution_latency = (fill_time - submission_time).total_seconds()

                    self.conn.execute('''
                        UPDATE execution_metrics SET
                            execution_time = ?,
                            execution_latency = ?,
                            execution_price = ?,
                            price_slippage = ?,
                            success = 1
                        WHERE order_id = ?
                    ''', (
                        order_info['filled_at'],
                        execution_latency,
                        float(order_info.get('filled_avg_price', 0)),
                        self._calculate_slippage(order_info),
                        order_info['id']
                    ))
                elif order_info['status'] in ('canceled', 'rejected'):
                    self.conn.execute('''
                        UPDATE execution_metrics SET
                            success = 0
                        WHERE order_id = ?
                    ''', (order_info['id'],))

        except sqlite3.Error as e:
            self.log_error(order_info.get('id'), 'database_error', str(e))
            raise

    def _calculate_slippage(self, order_info: Dict[str, Any]) -> float:
        """
        Calculates price slippage for an order.
        """
        try:
            intended_price = float(order_info.get('limit_price', 0) or order_info.get('stop_price', 0))
            if intended_price == 0:  # Market order
                return 0.0

            executed_price = float(order_info.get('filled_avg_price', 0))
            side = order_info['side']

            if side == 'buy' and intended_price != 0:
                slippage = (executed_price - intended_price) / intended_price * 100
            elif side == 'sell' and intended_price != 0:
                slippage = (intended_price - executed_price) / intended_price * 100
            else:
                slippage = 0.0

            return round(slippage, 4)

        except (KeyError, ValueError) as e:
            return 0.0

    def get_execution_metrics(self, start_time: Optional[str] = None, end_time: Optional[str] = None) -> list:
        """
        Retrieves execution metrics for analysis.
        """
        try:
            query = '''
                SELECT 
                    em.*,
                    o.ticker,
                    o.quantity,
                    o.side
                FROM execution_metrics em
                JOIN orders o ON em.order_id = o.order_id
                WHERE 1=1
            '''
            params = []

            if start_time:
                query += ' AND em.submission_time >= ?'
                params.append(start_time)
            if end_time:
                query += ' AND em.submission_time <= ?'
                params.append(end_time)

            cursor = self.conn.execute(query, params)
            metrics = cursor.fetchall()
            cursor.close()

            return metrics

        except sqlite3.Error as e:
            print(f"Error retrieving execution metrics: {e}")
            raise

    def get_order(self, order_id: str) -> Optional[Dict[str, Any]]:
        """
        Retrieves an order from the database.
        """
        try:
            cursor = self.conn.cursor()
            cursor.execute('SELECT * FROM orders WHERE order_id = ?', (order_id,))
            order = cursor.fetchone()
            col_names = [description[0] for description in cursor.description]
            cursor.close()

            if order:
                return dict(zip(col_names, order))
            return None

        except sqlite3.Error as e:
            self.log_error(order_id, 'database_error', str(e))
            raise

    def log_failed_trade(self, trade_signal, error_message: str):
        """
        Logs a failed trade for recovery.
        """
        try:
            with self.conn:
                self.conn.execute('''
                    INSERT INTO failed_trades (
                        trade_signal,
                        error_message,
                        timestamp,
                        status
                    ) VALUES (?, ?, ?, ?)
                ''', (
                    json.dumps(trade_signal.to_dict()),
                    str(error_message),
                    datetime.utcnow().isoformat(),
                    'pending'
                ))
        except sqlite3.Error as e:
            print(f"Error logging failed trade: {e}")
            raise

    def get_pending_failed_trades(self, max_retry_count: int = 3) -> list:
        """
        Retrieves pending failed trades for recovery.
        """
        try:
            cursor = self.conn.cursor()
            cursor.execute('''
                SELECT id, trade_signal, error_message, retry_count
                FROM failed_trades
                WHERE status = 'pending'
                AND retry_count < ?
                ORDER BY timestamp ASC
            ''', (max_retry_count,))
            failed_trades = cursor.fetchall()
            cursor.close()
            return failed_trades
        except sqlite3.Error as e:
            print(f"Error retrieving failed trades: {e}")
            raise

    def update_failed_trade_status(self, trade_id: int, status: str, error_message: Optional[str] = None):
        """
        Updates the status of a failed trade.
        """
        try:
            with self.conn:
                if status == 'retry':
                    self.conn.execute('''
                        UPDATE failed_trades
                        SET retry_count = retry_count + 1,
                            last_retry = ?,
                            error_message = CASE WHEN ? IS NOT NULL THEN ? ELSE error_message END
                        WHERE id = ?
                    ''', (datetime.utcnow().isoformat(), error_message, error_message, trade_id))
                else:
                    self.conn.execute('''
                        UPDATE failed_trades
                        SET status = ?,
                            resolved_at = ?
                        WHERE id = ?
                    ''', (status, datetime.utcnow().isoformat(), trade_id))
        except sqlite3.Error as e:
            print(f"Error updating failed trade status: {e}")
            raise

    def log_error(self, order_id: str, error_type: str, error_message: str, additional_info: Optional[Dict] = None):
        """
        Logs an error in the error_log table.
        """
        try:
            with self.conn:
                self.conn.execute('''
                    INSERT INTO error_log (
                        order_id,
                        error_type,
                        error_message,
                        timestamp,
                        additional_info
                    ) VALUES (?, ?, ?, ?, ?)
                ''', (
                    order_id,
                    error_type,
                    error_message,
                    datetime.utcnow().isoformat(),
                    json.dumps(additional_info) if additional_info else None
                ))
        except sqlite3.Error as e:
            print(f"Error logging error: {e}")
            raise

    def close(self):
        """
        Closes the database connection.
        """
        self.conn.close()


# File: components/trading_execution_engine/trade_signal.py
# Type: py

# File: components/trading_execution_engine/trade_signal.py
# Type: py

from dataclasses import dataclass
from datetime import datetime
from typing import Optional

@dataclass
class TradeSignal:
    """
    Represents a standardized trade signal with support for different order types.
    """
    ticker: str
    signal_type: str  # 'BUY' or 'SELL'
    quantity: float
    strategy_id: str
    timestamp: datetime
    price: Optional[float] = None  # Market price for reference
    order_type: str = 'market'  # 'market', 'limit', or 'stop'
    limit_price: Optional[float] = None  # Price for limit orders
    stop_price: Optional[float] = None  # Price for stop orders
    time_in_force: str = 'gtc'  # 'day', 'gtc', 'opg', 'cls', 'ioc', 'fok'

    def __post_init__(self):
        # Basic validation
        if self.signal_type not in ('BUY', 'SELL'):
            raise ValueError("signal_type must be 'BUY' or 'SELL'.")

        if self.order_type not in ('market', 'limit', 'stop'):
            raise ValueError("order_type must be 'market', 'limit', or 'stop'.")

        if self.time_in_force not in ('day', 'gtc', 'opg', 'cls', 'ioc', 'fok'):
            raise ValueError("Invalid time_in_force value.")

        # Validate limit and stop prices based on order type
        if self.order_type == 'limit' and self.limit_price is None:
            raise ValueError("limit_price is required for limit orders.")

        if self.order_type == 'stop' and self.stop_price is None:
            raise ValueError("stop_price is required for stop orders.")

    def to_dict(self) -> dict:
        """
        Serializes the TradeSignal to a dictionary.
        """
        return {
            'ticker': self.ticker,
            'signal_type': self.signal_type,
            'quantity': self.quantity,
            'strategy_id': self.strategy_id,
            'timestamp': self.timestamp.isoformat(),
            'price': self.price,
            'order_type': self.order_type,
            'limit_price': self.limit_price,
            'stop_price': self.stop_price,
            'time_in_force': self.time_in_force
        }

    @staticmethod
    def from_dict(data: dict) -> 'TradeSignal':
        """
        Deserializes a dictionary to a TradeSignal object.
        """
        required_fields = ['ticker', 'signal_type', 'quantity', 'strategy_id', 'timestamp']
        for field in required_fields:
            if field not in data:
                raise KeyError(f"Missing required field '{field}' in trade signal data.")
        return TradeSignal(
            ticker=data['ticker'],
            signal_type=data['signal_type'],
            quantity=float(data['quantity']),
            strategy_id=data['strategy_id'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            price=float(data['price']) if 'price' in data and data['price'] is not None else None,
            order_type=data.get('order_type', 'market'),
            limit_price=float(data['limit_price']) if 'limit_price' in data and data['limit_price'] is not None else None,
            stop_price=float(data['stop_price']) if 'stop_price' in data and data['stop_price'] is not None else None,
            time_in_force=data.get('time_in_force', 'gtc')
        )


